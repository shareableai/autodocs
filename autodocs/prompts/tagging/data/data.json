[
  {
    "trace": "[1] \ttorchvision.datasets.mnist.read_image_file\n[1] \ttorchvision.datasets.mnist.read_sn3_pascalvincent_tensor\n[2] \t\ttorchvision.datasets.mnist.get_int\n[1] \ttorchvision.datasets.mnist.read_label_file\n[2] \t\ttorchvision.datasets.mnist.read_sn3_pascalvincent_tensor\n[3] \t\t\ttorchvision.datasets.mnist.get_int\n[1] \ttorchvision.datasets.mnist.read_image_file\n[2] \t\ttorchvision.datasets.mnist.read_sn3_pascalvincent_tensor\n[3] \t\t\ttorchvision.datasets.mnist.get_int\n[1] \ttorch.utils.data.dataloader.DataLoader.check_worker_number_rationality\n[2] \t\ttorch.utils.data.dataloader.DataLoader.check_worker_number_rationality\n[1] \ttorch.nn.modules.conv._ConvNd.reset_parameters\n[2] \t\ttorch.nn.init.kaiming_uniform_\n[3] \t\t\ttorch.nn.init.kaiming_uniform_\n[4] \t\t\t\ttorch.nn.init.calculate_gain\n[5] \t\t\t\t\ttorch.nn.init.calculate_gain\n[2] \t\ttorch.nn.init.uniform_\n[3] \t\t\ttorch.nn.init.uniform_\n[1] \ttorch.nn.modules.linear.Linear.reset_parameters\n[2] \t\ttorch.nn.modules.linear.Linear.reset_parameters\n[3] \t\t\ttorch.nn.init.kaiming_uniform_\n[4] \t\t\t\ttorch.nn.init.kaiming_uniform_\n[5] \t\t\t\t\ttorch.nn.init.calculate_gain\n[6] \t\t\t\t\t\ttorch.nn.init.calculate_gain\n[3] \t\t\ttorch.nn.init.uniform_\n[4] \t\t\t\ttorch.nn.init.uniform_\n[1] \ttorch.nn.modules.module.Module.to\n[2] \t\ttorch.nn.modules.module.Module.children\n[2] \t\ttorch.nn.modules.module.Module.named_children\n[1] \ttorch.nn.modules.module.Module.parameters\n[1] \ttorch.nn.modules.module.Module.named_parameters\n[1] \ttorch.nn.modules.module.Module.named_modules\n[1] \ttorch.nn.modules.module.Module.train\n[2] \t\ttorch.nn.modules.module.Module.children\n[2] \t\ttorch.nn.modules.module.Module.named_children\n[1] \ttorch.distributed.is_available\n[2] \t\ttorch.distributed.is_available\n[1] \ttorch.distributed.distributed_c10d.is_initialized\n[1] \ttorch._ops.OpOverloadPacket.__call__\n[2] \t\ttorch._ops.OpOverloadPacket.__call__\n[1] \tPIL.Image.fromarray\n[2] \t\tPIL.Image.frombuffer\n[3] \t\t\tPIL.Image.new\n[1] \ttorchvision.transforms.transforms.Compose.__call__\n[2] \t\ttorchvision.transforms.transforms.ToTensor.__call__\n[3] \t\t\ttorchvision.transforms.functional.to_tensor\n[4] \t\t\t\tPIL.Image.Image.tobytes\n[5] \t\t\t\t\tPIL.Image.Image.load\n[4] \t\t\t\tPIL.ImageMode.getmode\n[4] \t\t\t\ttorchvision.transforms._functional_pil.get_image_num_channels\n[5] \t\t\t\t\tPIL.Image.Image.getbands\n[6] \t\t\t\t\t\tPIL.ImageMode.getmode\n[2] \t\ttorchvision.transforms.transforms.Normalize.forward\n[3] \t\t\ttorchvision.transforms.functional.normalize\n[4] \t\t\t\ttorchvision.transforms._functional_tensor.normalize\n[1] \ttorch.utils.data._utils.worker.get_worker_info\n[1] \ttorch._ops.OpOverload.__call__\n[2] \t\ttorch._ops.OpOverload.__call__\n[1] \ttorch.nn.modules.module.Module._call_impl\n[2] \t\t__main__.Net.forward\n[3] \t\t\ttorch.nn.modules.conv.Conv2d.forward\n[4] \t\t\t\ttorch.nn.modules.conv.Conv2d.forward\n[3] \t\t\ttorch.nn.functional.relu\n[4] \t\t\t\ttorch.nn.functional.relu\n[3] \t\t\ttorch.nn.functional.boolean_dispatch.<locals>.fn\n[4] \t\t\t\ttorch.nn.functional.boolean_dispatch.<locals>.fn\n[3] \t\t\ttorch.nn.modules.dropout.Dropout.forward\n[4] \t\t\t\ttorch.nn.modules.dropout.Dropout.forward\n[5] \t\t\t\t\ttorch.nn.functional.dropout\n[6] \t\t\t\t\t\ttorch.nn.functional.dropout\n[3] \t\t\ttorch.nn.modules.linear.Linear.forward\n[4] \t\t\t\ttorch.nn.modules.linear.Linear.forward\n[3] \t\t\ttorch.nn.functional.log_softmax\n[4] \t\t\t\ttorch.nn.functional.log_softmax\n[1] \ttorch.nn.functional.nll_loss\n[2] \t\ttorch.nn.functional.nll_loss\n[1] \ttorch.autograd.backward\n[2] \t\ttorch.autograd.backward\n[1] \ttorch.nn.modules.module.Module.eval\n[2] \t\ttorch.nn.modules.module.Module.train\n[3] \t\t\ttorch.nn.modules.module.Module.children\n[3] \t\t\ttorch.nn.modules.module.Module.named_children",
    "functions": "__main__.Net.forward\n     def forward(self, x):\n        x = self.conv1(x)\n        x = F.relu(x)\n        x = self.conv2(x)\n        x = F.relu(x)\n        x = F.max_pool2d(x, 2)\n        x = self.dropout1(x)\n        x = torch.flatten(x, 1)\n        x = self.fc1(x)\n        x = F.relu(x)\n        x = self.dropout2(x)\n        x = self.fc2(x)\n        output = F.log_softmax(x, dim=1)\n        return output\n\n\n__main__.Net.__init__\n     def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(1, 32, 3, 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, 1)\n        self.dropout1 = nn.Dropout(0.25)\n        self.dropout2 = nn.Dropout(0.5)\n        self.fc1 = nn.Linear(9216, 128)\n        self.fc2 = nn.Linear(128, 10)",
    "tags": ["image-classification", "classification" ,"vision"]
  },
  {
    "trace": "[1] \tnumpy.core.function_base.add_newdoc\n[1] \tnumpy.core.function_base.add_newdoc\n[1] \tsklearn.preprocessing._data.StandardScaler.fit\n[2] \t\tsklearn.preprocessing._data.StandardScaler.partial_fit\n[3] \t\t\tsklearn.base.BaseEstimator.get_params\n[3] \t\t\tsklearn.utils._param_validation.validate_parameter_constraints\n[3] \t\t\tsklearn.utils.validation.check_array\n[3] \t\t\tnumpy.any\n[3] \t\t\tnumpy.issubclass_\n[1] \tsklearn.preprocessing._data.StandardScaler.transform\n[2] \t\tsklearn.utils.validation.check_array\n[1] \tsklearn.base.BaseEstimator.get_params\n[1] \tsklearn.utils._param_validation.validate_parameter_constraints\n[2] \t\tsklearn.utils._param_validation.Interval.is_satisfied_by\n[2] \t\tsklearn.utils._param_validation.Options.is_satisfied_by\n[1] \tsklearn.utils.validation.check_X_y\n[1] \tnumpy.atleast_1d\n[1] \tsklearn.utils.multiclass.type_of_target\n[2] \t\tsklearn.utils.multiclass.is_multilabel\n[1] \tnumpy.copy\n[1] \tsklearn.base.clone\n[1] \tsklearn.base.BaseEstimator.set_params\n[2] \t\tsklearn.base.BaseEstimator.get_params\n[1] \tsklearn.utils.parallel.Parallel.__call__\n[2] \t\tnumpy.concatenate\n[2] \t\tnumpy.bincount\n[2] \t\tsklearn.tree._classes.DecisionTreeClassifier.fit\n[3] \t\t\tsklearn.tree._classes.BaseDecisionTree.fit\n[4] \t\t\t\tsklearn.base.BaseEstimator.get_params\n[4] \t\t\t\tsklearn.utils._param_validation.validate_parameter_constraints\n[5] \t\t\t\t\tsklearn.utils._param_validation.Interval.is_satisfied_by\n[5] \t\t\t\t\tsklearn.utils._param_validation.Options.is_satisfied_by\n[4] \t\t\t\tnumpy.concatenate\n[4] \t\t\t\tnumpy.atleast_1d\n[4] \t\t\t\tsklearn.utils.multiclass.type_of_target\n[5] \t\t\t\t\tsklearn.utils.multiclass.is_multilabel\n[5] \t\t\t\t\tnumpy.any\n[4] \t\t\t\tnumpy.copy",
    "functions": "",
    "tags": ["classification"]
  }
]