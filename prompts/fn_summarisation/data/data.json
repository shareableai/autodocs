[
  {
    "function": "def _dense_fit(self=SVC(gamma=0.001), X, y, sample_weight, solver_type, kernel='rbf', random_seed):\\n        if callable(self.kernel):\\n            # you must store a reference to X to compute the kernel in predict\\n            # TODO: add keyword copy to copy on demand\\n            self.__Xfit = X\\n            X = self._compute_kernel(X)\\n\\n            if X.shape[0] != X.shape[1]:\\n                raise ValueError(\\\"X.shape[0] should be equal to X.shape[1]\\\")\\n\\n        libsvm.set_verbosity_wrap(self.verbose)\\n\\n        # we don't pass **self.get_params() to allow subclasses to\\n        # add other parameters to __init__\\n        (\\n            self.support_,\\n            self.support_vectors_,\\n            self._n_support,\\n            self.dual_coef_,\\n            self.intercept_,\\n            self._probA,\\n            self._probB,\\n            self.fit_status_,\\n            self._num_iter,\\n        ) = libsvm.fit(\\n            X,\\n            y,\\n            svm_type=solver_type,\\n            sample_weight=sample_weight,\\n            # TODO(1.4): Replace \\\"_class_weight\\\" with \\\"class_weight_\\\"\\n            class_weight=getattr(self, \\\"_class_weight\\\", np.empty(0)),\\n            kernel=kernel,\\n            C=self.C,\\n            nu=self.nu,\\n            probability=self.probability,\\n            degree=self.degree,\\n            shrinking=self.shrinking,\\n            tol=self.tol,\\n            cache_size=self.cache_size,\\n            coef0=self.coef0,\\n            gamma=self._gamma,\\n            epsilon=self.epsilon,\\n            max_iter=self.max_iter,\\n            random_seed=random_seed,\\n        )\\n\\n        self._warn_from_fit_status()\\n",
    "summary": "Fit a SVM model with RBF kernel and gamma of 0.001"
  }
]